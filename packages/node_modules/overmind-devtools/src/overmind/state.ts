import { Derive } from 'overmind'
import {
  Action,
  App,
  Apps,
  Component,
  Flush,
  GroupedComponents,
  Tab,
  HistoryRecord,
  ExecutionType,
  MutationsMessage,
  HistoryRecordType,
  MutationHistoryRecord,
  FlushMessage,
  FlushHistoryRecord,
  EffectMessage,
  EffectHistoryRecord,
  OperatorsByPath,
} from './types'

type State = {
  isConnecting: boolean
  error: string
  port: string
  apps: Apps
  currentAppName: string
  newPortValue: string
  currentTab: Tab
  showApps: boolean
  currentAction: Derive<State, Action>
  currentApp: App
  componentsMounted: Derive<State, Component[]>
  componentsUpdateCount: Derive<State, number>
  componentsStatePathCount: Derive<State, number>
  flushes: Derive<State, Flush[]>
  flushesMutationsCount: Derive<State, number>
  flushesStatePathCount: Derive<State, number>
  groupedComponents: Derive<State, GroupedComponents>
  history: Derive<State, HistoryRecord<any, any>[]>
  currentOperatorsByPath: Derive<State, OperatorsByPath[]>
  runtimeHost: string
  runtimeError: string
  runtimeLoading: boolean
  runtimeConnected: boolean
  isShowingRuntimeConfig: boolean
}

const state: State = {
  isShowingRuntimeConfig: false,
  runtimeHost: '',
  runtimeError: null,
  runtimeLoading: true,
  runtimeConnected: false,
  isConnecting: true,
  error: null,
  showApps: false,
  currentAppName: null,
  port: '3031',
  apps: {},
  newPortValue: '',
  currentTab: Tab.State,
  get currentApp() {
    const state: State = this

    return state.apps[state.currentAppName]
  },
  componentsMounted: (state) =>
    Object.keys(state.currentApp.components).reduce(
      (aggr, key) => {
        if (state.currentApp.components[key].isMounted) {
          return aggr.concat(state.currentApp.components[key])
        }

        return aggr
      },
      [] as Component[]
    ),
  componentsUpdateCount: (state) =>
    state.componentsMounted.reduce(
      (aggr, component) => aggr + component.updateCount,
      0
    ),
  componentsStatePathCount: (state) =>
    state.componentsMounted.reduce(
      (aggr, component) => aggr + component.paths.length,
      0
    ),
  flushes: (state) =>
    Object.keys(state.currentApp.flushes)
      .sort(
        (idA, idB) =>
          state.currentApp.flushes[idB].flushId -
          state.currentApp.flushes[idA].flushId
      )
      .map((id) => state.currentApp.flushes[id]),
  flushesMutationsCount: (state) =>
    state.flushes.reduce((aggr, flush) => aggr + flush.mutations.length, 0),
  flushesStatePathCount: (state) =>
    state.flushes.reduce((aggr, flush) => {
      return flush.mutations.reduce(
        (aggr, mutation) =>
          aggr.includes(mutation.path) ? aggr : aggr.concat(mutation.path),
        aggr
      )
    }, []).length,
  currentAction: (state) =>
    state.currentApp.actions[state.currentApp.currentActionId],
  groupedComponents(state) {
    const components = state.componentsMounted

    return components.reduce(
      (aggr, component) => {
        if (aggr[component.name]) {
          aggr[component.name].components.push(component)
        } else {
          aggr[component.name] = {
            name: component.name,
            components: [component],
            isCollapsed: !state.currentApp.expandedComponents.includes(
              component.name
            ),
          }
        }

        return aggr
      },
      {} as GroupedComponents
    )
  },
  history: (state) => {
    return state.currentApp.messages.reduce((aggr, message) => {
      switch (message.type) {
        case ExecutionType.MUTATIONS:
          const mutationsMessage = message as MutationsMessage

          return aggr.concat(
            mutationsMessage.data.mutations.map((mutation) => {
              const mutationRecord: MutationHistoryRecord = {
                type: HistoryRecordType.Mutation,
                data: mutation,
                actionName: mutationsMessage.data.actionName,
              }

              return mutationRecord
            })
          )
        case ExecutionType.FLUSH:
          const flushMessage = message as FlushMessage
          const flush = state.currentApp.flushes[flushMessage.data.flushId]
          const flushRecord: FlushHistoryRecord = {
            type: HistoryRecordType.Flush,
            data: {
              components: flush.components.map(
                (componentId) => state.currentApp.components[componentId].name
              ),
              derived: flush.derived.map(
                (derivedId) => state.currentApp.derived[derivedId]
              ),
            },
            actionName: flushMessage.data.actionName,
          }

          return aggr.concat(flushRecord)
        case ExecutionType.EFFECT:
          const effectMessage = message as EffectMessage
          const effectRecord: EffectHistoryRecord = {
            type: HistoryRecordType.Effect,
            data: effectMessage.data,
            actionName: effectMessage.data.actionName,
          }

          return aggr.concat(effectRecord)
      }

      return aggr
    }, [])
  },
  currentOperatorsByPath: (state) => {
    const operators = Object.keys(state.currentAction.operators)
      .map((id) => Number(id))
      .sort((a, b) => a - b)
      .map((operatorId) => state.currentAction.operators[operatorId])

    return operators.reduce((aggr, operator): OperatorsByPath[] => {
      let currentValue = state.currentAction.value
      const traversePath = operator.path.slice()
      traversePath.unshift('')
      traversePath.reduce((childrenByPath, key, index) => {
        const isLastKey = index === traversePath.length - 1
        const matchingChildren = childrenByPath.find(
          (children) => children[0].path === key
        )
        const lastChildByPath = matchingChildren
          ? matchingChildren[matchingChildren.length - 1]
          : null

        if (isLastKey) {
          const newChild = {
            path: key,
            operator,
            childrenByPath: [],
            value: matchingChildren
              ? lastChildByPath.operator.result
              : currentValue,
          }

          matchingChildren
            ? matchingChildren.push(newChild)
            : childrenByPath.push([newChild])

          return
        }

        currentValue = lastChildByPath.value

        return lastChildByPath.childrenByPath
      }, aggr)

      return aggr
    }, [])
  },
}

export default state
