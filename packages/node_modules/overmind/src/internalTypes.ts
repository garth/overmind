// import { IMutation, IMutationTree } from 'proxy-state-tree'
// import { IAction, IOperator, IState } from './types'
import { IAction, IOperator } from './types'

export type SubType<Base, Condition> = Pick<
  Base,
  { [Key in keyof Base]: Base[Key] extends Condition ? Key : never }[keyof Base]
>

export type NestedPartial<T> = T extends Function
  ? T
  : Partial<{ [P in keyof T]: NestedPartial<T[P]> }>

export type Options = {
  name?: string
  devtools?: string | boolean
  logProxies?: boolean
  hotReloading?: boolean
}

export type DefaultMode = {
  mode: Symbol
}

export type TestMode = {
  mode: Symbol
  options: {
    effectsCallback: (
      effect: {
        effectId: number
        name: string
        method: string
        args: any[]
      }
    ) => {}
  }
}

export type SSRMode = {
  mode: Symbol
}

export enum EventType {
  ACTION_START = 'action:start',
  ACTION_END = 'action:end',
  OPERATOR_START = 'operator:start',
  OPERATOR_END = 'operator:end',
  OPERATOR_ASYNC = 'operator:async',
  // MUTATIONS = 'mutations',
  EFFECT = 'effect',
  // DERIVED = 'derived',
  // DERIVED_DIRTY = 'derived:dirty',
  COMPONENT_ADD = 'component:add',
  COMPONENT_UPDATE = 'component:update',
  COMPONENT_REMOVE = 'component:remove',
  // GETTER = 'getter',
}

export type Execution = {
  actionId: number
  executionId: number
  actionName: string
  operatorId: number
  isRunning: boolean
  parentExecution?: Execution
  path: string[]
  emit(event: EventType, value: any): void
  // flush(
  //   isAsync?: boolean
  // ): {
  //   mutations: IMutation[]
  //   flushId: number
  // }
  // getMutationTree(): IMutationTree<any>
  value?: any
  error?: string
}

export interface Events {
  [EventType.ACTION_START]: Execution
  [EventType.ACTION_END]: Execution
  [EventType.OPERATOR_START]: Execution & {
    path: string[]
    type: string
    name?: string
  }
  [EventType.OPERATOR_END]: Execution & {
    path: string[]
    isAsync: boolean
    result: any
  }
  [EventType.OPERATOR_ASYNC]: Execution & {
    path: string[]
    type: string
    name?: string
  }
  // [EventType.MUTATIONS]: Execution & {
  //   mutations: IMutation[]
  // }
  // [EventType.DERIVED]: {
  //   path: string
  //   paths: string[]
  //   updateCount: number
  //   value: any
  // }
  // [EventType.DERIVED_DIRTY]: {
  //   derivedPath: string[]
  //   path: string
  //   flushId: number
  // }
  [EventType.EFFECT]: Execution & {
    result: any
    name: string
    method: string
    args: any[]
    isPending: boolean
    error: string
    effectId: number
  }
  // [EventType.GETTER]: {
  //   path: string
  //   value: any
  // }
  [EventType.COMPONENT_ADD]: {
    componentId: number | string
    componentInstanceId: number
    name: string
    paths: string[]
  }
  [EventType.COMPONENT_UPDATE]: {
    componentId: number | string
    componentInstanceId: number
    name: string
    paths: string[]
    flushId?: number
  }
  [EventType.COMPONENT_REMOVE]: {
    componentId: number | string
    componentInstanceId: number
    name: string
  }
}

// ============= PRIVATE TYPES FOR APP

// type Derived = (parent: any, config: any) => any

// export type ResolveState<State extends IState> = State extends undefined
//   ? {}
//   : {
//       [P in keyof State]: State[P] extends Derived
//         ? ReturnType<State[P]>
//         : State[P] extends Array<any>
//         ? State[P]
//         : State[P] extends IState
//         ? ResolveState<State[P]>
//         : State[P]
//     }

type NestedActions =
  | {
      [key: string]:
        | IAction<any, any, any>
        | IOperator<any, any, any>
        | NestedActions
    }
  | undefined

type TActionValue<T> = T extends (a1: any, a2: infer TValue) => any
  ? TValue
  : never

export type ResolveActions<
  Actions extends NestedActions
> = Actions extends undefined
  ? {}
  : {
      [T in keyof Actions]: Actions[T] extends IOperator<any, any, any>
        ? TActionValue<Actions[T]> extends void
          ? () => Promise<void>
          : (value: TActionValue<Actions[T]>) => Promise<void>
        : Actions[T] extends IAction<any, any, any>
        ? TActionValue<Actions[T]> extends void
          ? () => ReturnType<Actions[T]>
          : (value: TActionValue<Actions[T]>) => ReturnType<Actions[T]>
        : Actions[T] extends NestedActions
        ? ResolveActions<Actions[T]>
        : never
    }

type NestedMockActions =
  | {
      [key: string]:
        | IAction<any, any, any>
        | IOperator<any, any, any>
        | NestedMockActions
    }
  | undefined

// type MockResult = IMutation[]

// export type ResolveMockActions<
//   Actions extends NestedMockActions
// > = Actions extends undefined
//   ? {}
//   : {
//       [T in keyof Actions]: Actions[T] extends IOperator<any, any, any>
//         ? TActionValue<Actions[T]> extends void
//           ? () => Promise<MockResult>
//           : (value: TActionValue<Actions[T]>) => Promise<MockResult>
//         : Actions[T] extends IAction<any, any, any>
//         ? TActionValue<Actions[T]> extends void
//           ? () => Promise<MockResult>
//           : (value: TActionValue<Actions[T]>) => Promise<MockResult>
//         : Actions[T] extends NestedMockActions
//         ? ResolveMockActions<Actions[T]>
//         : undefined
//     }
