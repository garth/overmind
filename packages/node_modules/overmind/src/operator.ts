// import { IS_PRODUCTION, IS_OPERATOR, makeStringifySafeMutations } from './utils'
import { IS_PRODUCTION, IS_OPERATOR } from './utils'
import { EventType } from './internalTypes'
import { safeValue } from './Devtools'
import { IContext, IConfiguration } from './types'

export function operatorStarted(type, arg, context) {
  if (IS_PRODUCTION) {
    return
  }
  const name =
    typeof arg === 'function' ? arg.displayName || arg.name : String(arg)

  context.execution.emit(EventType.OPERATOR_START, {
    ...context.execution,
    name,
    type,
  })
}

export function operatorStopped(
  context,
  value,
  details: {
    error?: Error
    isIntercepted?: boolean
    isSkipped?: boolean
  } = {}
) {
  if (IS_PRODUCTION) {
    if (value instanceof Promise) {
      context.execution.emit(EventType.OPERATOR_ASYNC, {
        ...context.execution,
        isAsync: true,
      })
    }
    return
  }

  const evaluatedDetails = {
    error: details.error ? details.error.message : undefined,
    isIntercepted: Boolean(details.isIntercepted),
    isSkipped: Boolean(details.isSkipped),
  }

  if (value instanceof Promise) {
    value
      .then((promiseValue) => {
        context.execution.emit(EventType.OPERATOR_END, {
          ...context.execution,
          result: safeValue(promiseValue),
          isAsync: true,
          ...evaluatedDetails,
        })
      })
      .catch(() => {
        // Make sure an error does not cause uncaught
      })
  } else {
    context.execution.emit(EventType.OPERATOR_END, {
      ...context.execution,
      result: safeValue(value),
      isAsync: false,
      ...evaluatedDetails,
    })
  }
}

export function createContext(context, value, path?) {
  if (IS_PRODUCTION) {
    return {
      ...context,
      value,
    }
  }

  const newExecution = {
    ...context.execution,
    operatorId: context.execution.getNextOperatorId(),
    path: path || context.execution.path,
  }

  return {
    ...context,
    value,
    execution: newExecution,
    // effects: context.execution.trackEffects(newExecution),
  }
}

export function createNextPath(next) {
  if (IS_PRODUCTION) {
    return next
  }

  return (err, context) => {
    const newContext = {
      ...context,
      execution: {
        ...context.execution,
        path: context.execution.path.slice(
          0,
          context.execution.path.length - 1
        ),
      },
    }
    if (err) next(err, newContext)
    else next(null, newContext)
  }
}

export function createOperator<ThisConfig extends IConfiguration>(
  type: string,
  name: string,
  cb: (
    err: Error | null,
    context: IContext<ThisConfig>,
    value: any,
    next: (
      err: Error | null,
      value: any,
      options?: {
        path?: { name: string; operator: Function }
        isSkipped?: boolean
      }
    ) => void,
    final: (err: Error | null, value: any) => void
  ) => any
): any {
  const operator = (err, context, next, final) => {
    operatorStarted(type, name, context)
    let asyncTimeout = setTimeout(() => {
      context.execution.emit(EventType.OPERATOR_ASYNC, {
        ...context.execution,
        isAsync: true,
      })
    })
    try {
      cb(
        err,
        {
          // state: context.state,
          effects: context.effects,
          actions: context.actions,
        },
        context.value,
        (err, value, options = {}) => {
          function run(err, value) {
            if (options.path) {
              const newContext = createContext(
                context,
                value,
                context.execution.path &&
                  context.execution.path.concat(options.path.name)
              )
              const nextWithPath = createNextPath(next)
              options.path.operator(err, newContext, (...args) => {
                operatorStopped(context, args[1].value)
                nextWithPath(...args)
              })
            } else {
              operatorStopped(context, err || value, {
                isSkipped: err ? true : options.isSkipped,
              })
              next(err, createContext(context, value))
            }
          }

          if (value && value instanceof Promise) {
            value
              .then((promiseValue) => run(err, promiseValue))
              .catch((promiseError) => run(promiseError, promiseError))
          } else {
            clearTimeout(asyncTimeout)
            run(err, value)
          }
        },
        (err, value) => {
          clearTimeout(asyncTimeout)
          operatorStopped(context, err || value, {
            isSkipped: Boolean(err),
            isIntercepted: !err,
          })
          final(err, createContext(context, value))
        }
      )
    } catch (error) {
      clearTimeout(asyncTimeout)
      operatorStopped(context, context.value, {
        error,
      })
      next(error, createContext(context, context.value))
    }
  }

  operator[IS_OPERATOR] = true

  return operator
}

// export function createMutationOperator<ThisConfig extends IConfiguration>(
//   type: string,
//   name: string,
//   cb: (
//     err: Error | null,
//     context: IContext<ThisConfig>,
//     value: any,
//     next: (
//       err: Error | null,
//       value: any,
//       options?: {
//         path?: { name: string; operator: Function }
//         isSkipped?: boolean
//       }
//     ) => void,
//     final: (err: Error | null, value: any) => void
//   ) => any
// ): any {
//   const operator = (err, context, next, final) => {
//     operatorStarted(type, name, context)
//     // const mutationTree = context.execution.getMutationTree()
//     // if (!IS_PRODUCTION) {
//     //   mutationTree.onMutation((mutation) => {
//     //     context.execution.emit(EventType.MUTATIONS, {
//     //       ...context.execution,
//     //       mutations: makeStringifySafeMutations([mutation]),
//     //     })
//     //   })
//     // }
//     let asyncTimeout = setTimeout(() => {
//       context.execution.emit(EventType.OPERATOR_ASYNC, {
//         ...context.execution,
//         isAsync: true,
//       })
//     })
//     try {
//       cb(
//         err,
//         {
//           // state: mutationTree.state,
//           effects: context.effects,
//           actions: context.actions,
//         },
//         context.value,
//         // IS_PRODUCTION
//         //   ? context.value
//         //   : context.execution.scopeValue(context.value, mutationTree),
//         (err, value, options = {}) => {
//           function run(err, value) {
//             operatorStopped(context, err || value, {
//               isSkipped: err ? true : options.isSkipped,
//             })
//             next(err, createContext(context, value))
//           }

//           if (value && value instanceof Promise) {
//             value
//               .then((promiseValue) => run(err, promiseValue))
//               .catch((promiseError) => run(promiseError, promiseError))
//           } else {
//             clearTimeout(asyncTimeout)
//             run(err, value)
//           }
//         },
//         (err, value) => {
//           clearTimeout(asyncTimeout)
//           operatorStopped(context, err || value, {
//             isSkipped: Boolean(err),
//             isIntercepted: !err,
//           })
//           final(err, createContext(context, value))
//         }
//       )

//       // if (!IS_PRODUCTION) {
//       //   let pendingFlush
//       //   mutationTree.onMutation(() => {
//       //     if (pendingFlush) {
//       //       clearTimeout(pendingFlush)
//       //     }
//       //     pendingFlush = setTimeout(() => {
//       //       const flushData = mutationTree.flush(true)

//       //       if (flushData.mutations.length) {
//       //         context.execution.send({
//       //           type: 'flush',
//       //           data: {
//       //             ...context.execution,
//       //             ...flushData,
//       //             mutations: makeStringifySafeMutations(flushData.mutations),
//       //           },
//       //         })
//       //       }
//       //     })
//       //   })
//       // }
//     } catch (error) {
//       clearTimeout(asyncTimeout)
//       operatorStopped(context, context.value, {
//         error,
//       })
//       next(error, createContext(context, context.value))
//     }
//   }

//   operator[IS_OPERATOR] = true

//   return operator
// }
