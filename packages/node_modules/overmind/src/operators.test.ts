import {
  Overmind,
  pipe,
  map,
  forEach,
  filter,
  fork,
  when,
  IOperator,
  wait,
  debounce,
  // mutate,
  parallel,
  IConfig,
  IAction,
  catchError,
  tryCatch,
} from './'

describe('OPERATORS', () => {
  // test('map', () => {
  //   expect.assertions(1)
  //   const test: Operator<string> = pipe(
  //     map((_, value) => value.toUpperCase()),
  //     mutate(({ state }, value) => (state.foo = value))
  //   )

  //   const state = {
  //     foo: 'bar',
  //   }

  //   const config = {
  //     state,
  //     actions: {
  //       test,
  //     },
  //   }
  //   const overmind = new Overmind(config)

  //   type Config = IConfig<typeof config>

  //   interface Operator<Input = void, Output = Input>
  //     extends IOperator<Config, Input, Output> {}

  //   return overmind.actions.test('foo').then(() => {
  //     expect(overmind.state.foo).toBe('FOO')
  //   })
  // })

  // test('map (async)', () => {
  //   expect.assertions(1)
  //   const test: Operator<string> = pipe(
  //     map((_, value) => Promise.resolve(value.toUpperCase())),
  //     mutate(({ state }, value) => (state.foo = value))
  //   )

  //   const state = {
  //     foo: 'bar',
  //   }

  //   const config = {
  //     state,
  //     actions: {
  //       test,
  //     },
  //   }
  //   const overmind = new Overmind(config)

  //   type Config = IConfig<typeof config>

  //   interface Operator<Input = void, Output = Input>
  //     extends IOperator<Config, Input, Output> {}

  //   interface Action<Input = void> extends IAction<Config, Input> {}

  //   return overmind.actions.test('foo').then(() => {
  //     expect(overmind.state.foo).toBe('FOO')
  //   })
  // })

  test('forEach', () => {
    expect.assertions(1)
    let runCount = 0
    const operator: any = (_, val, next) => {
      runCount++
      next(null, val)
    }
    const test: Operator<string[]> = pipe(forEach(operator))

    const config = {
      actions: {
        test,
      },
    }
    const overmind = new Overmind(config)

    type Config = IConfig<typeof config>

    interface Operator<Input = void, Output = Input>
      extends IOperator<Config, Input, Output> {}

    interface Action<Input = void> extends IAction<Config, Input> {}

    return overmind.actions.test(['foo']).then(() => {
      expect(runCount).toEqual(1)
    })
  })

  test('parallel', () => {
    expect.assertions(1)
    let runCount = 0
    const operator: any = (_, value, next) => {
      runCount++
      next(null, value)
    }
    const test: Operator<string> = pipe(parallel(operator, operator))

    const config = {
      actions: {
        test,
      },
    }
    const overmind = new Overmind(config)

    type Config = IConfig<typeof config>

    interface Operator<Input = void, Output = Input>
      extends IOperator<Config, Input, Output> {}

    interface Action<Input = void> extends IAction<Config, Input> {}

    return overmind.actions.test('foo').then(() => {
      expect(runCount).toEqual(2)
    })
  })

  // test('filter - truthy', () => {
  //   expect.assertions(1)
  //   const test: Operator<string> = pipe(
  //     filter((_, value) => value === 'foo'),
  //     map((_, value) => value.toUpperCase()),
  //     mutate(({ state }, value) => (state.foo = value))
  //   )

  //   const state = {
  //     foo: 'bar',
  //   }
  //   const config = {
  //     state,
  //     actions: {
  //       test,
  //     },
  //   }
  //   const overmind = new Overmind(config)

  //   type Config = IConfig<typeof config>

  //   interface Operator<Input = void, Output = Input>
  //     extends IOperator<Config, Input, Output> {}

  //   return overmind.actions.test('foo').then(() => {
  //     expect(overmind.state.foo).toBe('FOO')
  //   })
  // })

  // test('filter - falsy', () => {
  //   const test: Operator<string> = pipe(
  //     filter((_, value) => value === 'bar'),
  //     map((_, value) => value.toUpperCase()),
  //     mutate(({ state }, value) => (state.foo = value))
  //   )

  //   const state = {
  //     foo: 'bar',
  //   }
  //   const config = {
  //     state,
  //     actions: {
  //       test,
  //     },
  //   }
  //   const overmind = new Overmind(config)

  //   type Config = IConfig<typeof config>

  //   interface Operator<Input = void, Output = Input>
  //     extends IOperator<Config, Input, Output> {}

  //   return overmind.actions.test('foo').then(() => {
  //     expect(overmind.state.foo).toBe('bar')
  //   })
  // })

  // test('fork', () => {
  //   expect.assertions(1)
  //   const test: Operator<string> = pipe(
  //     fork(() => 'foo', {
  //       foo: pipe(
  //         map((_, value) => value.toUpperCase()),
  //         mutate(({ state }, value) => (state.foo = value))
  //       ),
  //     })
  //   )

  //   const state = {
  //     foo: 'bar',
  //   }
  //   const config = {
  //     state,
  //     actions: {
  //       test,
  //     },
  //   }
  //   const overmind = new Overmind(config)

  //   type Config = IConfig<typeof config>

  //   interface Operator<Input = void, Output = Input>
  //     extends IOperator<Config, Input, Output> {}

  //   interface Action<Input = void> extends IAction<Config, Input> {}

  //   return overmind.actions.test('foo').then(() => {
  //     expect(overmind.state.foo).toBe('FOO')
  //   })
  // })

  // test('when', () => {
  //   expect.assertions(1)
  //   const test: Operator<string, string | number> = pipe(
  //     when(() => true, {
  //       true: pipe(
  //         map((_, value) => value.toUpperCase()),
  //         mutate(({ state }, value) => (state.foo = value))
  //       ),
  //       false: pipe(
  //         map((_, value) => Number(value)),
  //         mutate(({ state }, value) => (state.number = value))
  //       ),
  //     })
  //   )

  //   const state = {
  //     foo: 'bar',
  //     number: 0,
  //   }
  //   const config = {
  //     state,
  //     actions: {
  //       test,
  //     },
  //   }
  //   const overmind = new Overmind(config)

  //   type Config = IConfig<typeof config>

  //   interface Operator<Input = void, Output = Input>
  //     extends IOperator<Config, Input, Output> {}

  //   interface Action<Input = void> extends IAction<Config, Input> {}

  //   return overmind.actions.test('foo').then(() => {
  //     expect(overmind.state.foo).toBe('FOO')
  //   })
  // })

  test('wait', () => {
    expect.assertions(1)
    const runTime = Date.now()
    const test: Operator = wait(500)

    const config = {
      actions: {
        test,
      },
    }
    const overmind = new Overmind(config)

    type Config = IConfig<typeof config>

    interface Operator<Input = void, Output = Input>
      extends IOperator<Config, Input, Output> {}

    interface Action<Input = void> extends IAction<Config, Input> {}

    return overmind.actions.test().then(() => {
      expect(Date.now() - runTime).toBeGreaterThanOrEqual(500)
    })
  })

  // test('debounce', () => {
  //   expect.assertions(1)
  //   const test: Operator = pipe(
  //     debounce(100),
  //     mutate(({ state }) => state.runCount++)
  //   )
  //   const state = {
  //     runCount: 0,
  //   }
  //   const config = {
  //     state,
  //     actions: {
  //       test,
  //     },
  //   }
  //   const overmind = new Overmind(config)

  //   type Config = IConfig<typeof config>

  //   interface Operator<Input = void, Output = Input>
  //     extends IOperator<Config, Input, Output> {}

  //   return Promise.all([overmind.actions.test(), overmind.actions.test()]).then(
  //     () => {
  //       expect(overmind.state.runCount).toBe(1)
  //     }
  //   )
  // })
  // test('catchError', () => {
  //   expect.assertions(3)
  //   const test: Operator<string> = pipe(
  //     mutate(() => {
  //       throw new Error('wut?!?')
  //     }),
  //     mutate(({ state }) => {
  //       state.runCount++
  //     }),
  //     catchError(({ state }, error) => {
  //       state.error = error.message

  //       return 'hm'
  //     }),
  //     mutate(({ state }, value) => {
  //       state.foo = value
  //     })
  //   )
  //   const state = {
  //     runCount: 0,
  //     foo: 'bar',
  //     error: '',
  //   }
  //   const config = {
  //     state,
  //     actions: {
  //       test,
  //     },
  //   }
  //   const overmind = new Overmind(config)

  //   type Config = IConfig<typeof config>

  //   interface Operator<Input = void, Output = Input>
  //     extends IOperator<Config, Input, Output> {}

  //   return overmind.actions.test('baz').then(() => {
  //     expect(overmind.state.runCount).toBe(0)
  //     expect(overmind.state.error).toBe('wut?!?')
  //     expect(overmind.state.foo).toBe('hm')
  //   })
  // })
  // test('tryCatch - resolves', () => {
  //   expect.assertions(1)
  //   const test: Operator<string> = tryCatch({
  //     try: mutate(({ state }, value) => {
  //       state.foo = value
  //     }),
  //     catch: mutate(() => {}),
  //   })
  //   const state = {
  //     foo: 'bar',
  //   }
  //   const config = {
  //     state,
  //     actions: {
  //       test,
  //     },
  //   }
  //   const overmind = new Overmind(config)

  //   type Config = IConfig<typeof config>

  //   interface Operator<Input = void, Output = Input>
  //     extends IOperator<Config, Input, Output> {}

  //   return overmind.actions.test('baz').then(() => {
  //     expect(overmind.state.foo).toBe('baz')
  //   })
  // })
  // test.only('tryCatch - fails', () => {
  //   expect.assertions(1)
  //   const test: Operator<string> = pipe(
  //     tryCatch({
  //       try: mutate(() => {
  //         throw new Error('ehm')
  //       }),
  //       catch: mutate(({ state }, value) => {
  //         state.foo = value.message
  //       }),
  //     })
  //   )
  //   const state = {
  //     foo: 'bar',
  //   }
  //   const config = {
  //     state,
  //     actions: {
  //       test,
  //     },
  //   }
  //   const overmind = new Overmind(config)

  //   type Config = IConfig<typeof config>

  //   interface Operator<Input = void, Output = Input>
  //     extends IOperator<Config, Input, Output> {}

  //   return overmind.actions.test('baz').then(() => {
  //     expect(overmind.state.foo).toBe('ehm')
  //   })
  // })
})
