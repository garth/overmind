// import { ResolveActions, ResolveState } from './internalTypes'
import { ResolveActions } from './internalTypes'
import { Overmind } from './'
import { IS_OPERATOR } from './utils'

/** ===== PUBLIC API
 */
export { EventType } from './internalTypes'

export type IConfiguration = {
  onInitialize?: any
  // state?: {}
  effects?: {}
  actions?: {}
}

// export type IState =
//   | {
//       [key: string]:
//         | IState
//         | string
//         | IDerive<any, any, any>
//         | number
//         | boolean
//         | object
//         | null
//         | undefined
//     }
//   | undefined

export interface IConfig<ThisConfig extends IConfiguration> {
  // state: ThisConfig['state'] & {}
  actions: ThisConfig['actions'] & {}
  effects: ThisConfig['effects'] & {}
}

export type IContext<ThisConfig extends IConfiguration> = {
  // state: ResolveState<ThisConfig['state']>
  actions: ResolveActions<ThisConfig['actions']>
  effects: ThisConfig['effects']
}

export interface IAction<
  ThisConfig extends IConfiguration,
  Value,
  ReturnValue = void | Promise<void>
> {
  <InferredReturnValue extends ReturnValue>(
    context: IContext<ThisConfig>,
    value: Value
  ): ReturnValue extends Promise<any>
    ? ReturnValue
    : InferredReturnValue | ReturnValue
}

// We do not type operators as their low level implementation, but rather
// how it is consumed by the developer
export interface IOperator<
  ThisConfig extends IConfiguration,
  Input,
  Output = Input
> {
  (context: IContext<ThisConfig>, value: Input): Output
  [IS_OPERATOR]: true
}

// export type IDerive<
//   ThisConfig extends IConfiguration,
//   Parent extends IState,
//   Value
// > = (
//   parent: ResolveState<Parent>,
//   state: ResolveState<ThisConfig['state'] & {}>
// ) => Value

export interface IOnInitialize<ThisConfig extends IConfiguration> {
  (context: IContext<ThisConfig>, value: Overmind<ThisConfig>): void
}
