// import isPlainObject from 'is-plain-obj'
// import { IMutation } from 'proxy-state-tree'
// import { safeValues } from './Devtools'

export const IS_TEST = process.env.NODE_ENV === 'test'
export const IS_PRODUCTION = process.env.NODE_ENV === 'production'
export const IS_DEVELOPMENT =
  !process.env.NODE_ENV || process.env.NODE_ENV === 'development'
export const IS_OPERATOR = Symbol('operator')
export const ORIGINAL_ACTIONS = Symbol('origina_actions')

export class MockedEventEmitter {
  emit() {}
  emitAsync() {}
  on() {}
  once() {}
  addListener() {}
}

export function getFunctionName(func: Function) {
  return func.name || (func as any).displayName || ''
}

// export const makeStringifySafeMutations = (mutations: IMutation[]) => {
//   return mutations.map((mutation) => ({
//     ...mutation,
//     args: safeValues(mutation.args),
//   }))
// }

// export function deepCopy(obj) {
//   if (isPlainObject(obj)) {
//     return Object.keys(obj).reduce((aggr: any, key) => {
//       if (key === '__esModule') {
//         return aggr
//       }

//       const originalDescriptor = Object.getOwnPropertyDescriptor(obj, key)
//       const isAGetter = originalDescriptor && 'get' in originalDescriptor
//       const value = obj[key]

//       if (isPlainObject(value) && !isAGetter) {
//         aggr[key] = deepCopy(value)
//       } else {
//         Object.defineProperty(aggr, key, originalDescriptor as any)
//       }

//       return aggr
//     }, {})
//   } else if (Array.isArray(obj)) {
//     return obj.map((item) => deepCopy(item))
//   }

//   return obj
// }

// export function mergeState(originState, oldState, nextState) {
//   function merge(origin, old, next) {
//     if (isPlainObject(old) && isPlainObject(next)) {
//       const newBranch = {}

//       for (let key in next) {
//         newBranch[key] = merge(origin[key], old[key], next[key])
//       }

//       return newBranch
//     }

//     if (typeof next === 'function') {
//       return next
//     }

//     // We return the existing array, as arrays are typically
//     // mutated, not set with new values as initial state
//     if (Array.isArray(old) && Array.isArray(next)) {
//       return old
//     }

//     // If we have changed a state from origin, keep that
//     // changed state
//     if (next === origin && old !== origin) {
//       return old
//     }

//     return next
//   }

//   return merge(originState, oldState, nextState)
// }

export function getActionPaths(actions = {}, currentPath: string[] = []) {
  return Object.keys(actions).reduce<string[]>((aggr, key) => {
    if (typeof actions[key] === 'function') {
      return aggr.concat(currentPath.concat(key).join('.'))
    }

    return aggr.concat(getActionPaths(actions[key], currentPath.concat(key)))
  }, [])
}

// export function createActionsProxy(actions, cb) {
//   return new Proxy(actions, {
//     get(target, prop) {
//       if (prop === ORIGINAL_ACTIONS) {
//         return actions
//       }

//       if (typeof target[prop] === 'function') {
//         return cb(target[prop])
//       }

//       if (!target[prop]) {
//         throw new Error(
//           `You are pointing towards an action that does not exist. "${String(
//             prop
//           )}" does not exist`
//         )
//       }

//       return createActionsProxy(target[prop], cb)
//     },
//   })
// }
